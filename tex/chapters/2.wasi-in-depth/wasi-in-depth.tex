\chapter{WASI, nel dettaglio}
\label{chap:wasi-in-depth}
L'obiettivo principale di WASI è fornire un set di API standard per WebAssembly, indipendenti dal motore di esecuzione
sottostante. Per raggiungere questo obiettivo è stato necessario creare, in prima istanza, un primo modulo su cui basare
tutti gli altri. Questo modulo è stato chiamato WASI-Core e ha lo scopo di fornire le funzionalità di base per
l'ambiente di esecuzione, come la gestione dei file, delle reti e di essere generico in modo da poter essere utilizzato
in qualsiasi ambiente fuori dal browser. Al di fuori del contesto web, WebAssembly ha bisogno di una serie di API per
interagire con il sistema operativo sottostante, ovvero una libreria di sistema per Wasm. Questa libreria, chiamata
WASI-libc è in grado di fornire un ponte tra i moduli Wasm e le system call del sistema sottostante. È basata sullo
standard POSIX ed in particolare su musl-libc\footnote{\url{http://musl.libc.org/}} ed utilizza le funzioni di
libpreopen\footnote{\url{https://github.com/musec/libpreopen}}.
% È basata sullo standard POSIX in particolare su musl-libc\footnote{\url{http://musl.libc.org/}}, un'implementazione
% dello standard POSIX costruita sulle system call di Linux ed utilizza le funzioni di
% libpreopen\footnote{\url{https://github.com/musec/libpreopen}}, un insieme di funzioni che consente solo l'uso di file
% descriptor già aperti in precedenza, prevenendo così la possibilità di aprire file descriptor direttamente. Questi
% file descriptor sono aperti dai runtime WASI e passati all'applicazione in un secondo momento, in modo da rispettare
% il capability-based security model. L'implementazione di WASI-libc non porta include funzioni come fork() o exec() in
% quanto complesse da sviluppare in ambito sandbox e al momento fuori dallo scope del progetto.

\section{WASI-libc}
WASI-libc\footnote{\url{https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md}} è una libreria che
definisce un'interfaccia C standard per le system call necessarie a WebAssembly. È il ponte fondamentale che unisce i
moduli Wasm con il sottostante sistema operativo. L'obiettivo chiave della libreria è quello di fornire un set di
funzioni che si comportino come quelle dello standard POSIX, ma che siano implementate specificamente per WebAssembly
tra cui l'allocazione e la manipolazione della memoria, l'I/O dei file, la gestione delle stringhe, le funzioni
matematiche e così via. Essendo un'implementazione personalizzata, non include tutte le funzioni standard di POSIX. Ad
esempio funzioni come la fork() e l'exec() sono escluse in quanto complesse da implementare in ambito sandbox e
difficili da gestire secondo il modello capability-based. La libreria è basata su due altre librerie già esistenti: la
musl-libc e la libpreopen.
\subsection{Musl-libc}
Musl-libc è una libreria standard del linguaggio C che fornisce una serie di funzioni predefinite per semplificare lo
sviluppo di software. La libreria è stata progettata per essere leggera, efficiente e altamente portabile, ed è stata
sviluppata con un focus particolare sulla compatibilità POSIX. Si propone come un'alternativa più leggera e veloce
rispetto alla GNU C Library (glibc). Tra le funzionalità supportate da musl-libc vi sono la gestione della memoria, le
operazioni su stringhe, la gestione dei file, i socket di rete e la gestione dei processi.
\subsection{Libpreopen}
Libpreopen è una libreria che fornisce un meccanismo per caricare in anticipo e intercettare le operazioni sui file in
un sistema operativo. Consente alle applicazioni di aprire i file utilizzando un insieme predefinito di regole e
percorsi, anziché il percorso effettivo sul file system. Libpreopen intercetta le chiamate di sistema relative ai file,
come open(), stat() e opendir(), e le traduce in operazioni definite dalle applicazioni. Ciò può essere utile in
situazioni in cui un'applicazione deve accedere a file che si trovano in una directory o un archivio specifico, o quando
un'applicazione deve isolare le sue operazioni sui file. Libpreopen consente all'applicazione di specificare un insieme
di regole che definiscono come i file devono essere accessibili. Ad esempio, un'applicazione potrebbe specificare che
tutte le operazioni sui file dovrebbero essere eseguite in una directory o file system montato specifico, o che
determinati file dovrebbero essere in sola lettura o scrittura. Su questi concetti si basa il capability-based security
di WASI ed è perciò di fondamentale importanza per il suo funzionamento.
% \subsection{Perché è necessaria una libc?} È il mattoncino base fondamentale per l'interazione con il sistema
% operativo sottostante, in quanto fornisce le funzioni standard di base necessarie per lo sviluppo delle applicazioni.
% Senza una libreria standard come la libc, gli sviluppatori dovrebbero scrivere manualmente il codice per queste
% funzioni di basso livello, il che sarebbe molto laborioso e inefficiente. Si noti che la libc non è un requisito
% esclusivo di WASI, è la base su cui poggiano tutti i sistemi informatici moderni!
\section{La sicurezza con WASI}
% WASI segue il 'principle of least privilege' e il 'capability-based security model'.
\subsection{Il problema}
Nell'ambito dello sviluppo software, l'utilizzo di librerie esterne è diventato una pratica comune per facilitare la
creazione di applicazioni complesse. Queste librerie open source, disponibili sotto forma di pacchetti software, sono
facilmente accessibili tramite l'uso di appositi strumenti chiamati package manager. I package manager sono strumenti di
gestione del software che consentono di gestire, salvare e distribuire le librerie di codice necessarie alla creazione
di un'applicazione. Inoltre, consentono di installare automaticamente tutte le dipendenze richieste per far funzionare
un software, semplificando notevolmente il processo di integrazione di nuove funzionalità all'interno di
un'applicazione. Con l'utilizzo di un package manager, gli sviluppatori possono concentrarsi maggiormente sullo sviluppo
di funzionalità specifiche, piuttosto che sulla gestione delle dipendenze.
\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=8cm]{./chapters/2.wasi-in-depth/images/1.malicious_or_vuln_code.png}
    \label{app_package}
    \caption{Come sono composte le applicazioni moderne}
\end{figure}
In questo modo, è possibile ridurre il lavoro necessario per la creazione di applicazioni complesse, migliorare
l'efficienza del processo di sviluppo e aumentare la qualità del software prodotto. D'altra parte, questo modello di
sviluppo espone le applicazioni ad una grossa problematica, cosa succederebbe se in uno di questi pacchetti software ci
fosse inserito codice malevolo o codice vulnerabile? Purtroppo non è uno scenario remoto:
\begin{quote}
    The average application development project has 49 vulnerabilities and 80 direct dependencies (open source code
    called by a project); \\
    \textit{Snyk 2019 State of Open Source Security
    Report}\footnote{\url{https://snyk.io/reports/open-source-security/}}
\end{quote}
Per peggiorare le cose, non tutte queste vulnerabilità vengono risolte, si stima che solo il 59\% dei pacchetti software
risolva le vulnerabilità trovate.
\subsection{Una possibile soluzione}
Esistono diverse strategie che gli sviluppatori possono adottare per proteggere il loro software e gli utenti finali. Ad
esempio, si potrebbe utilizzare uno scanner per controllare le applicazioni e le dipendenze, tuttavia questa soluzione
non è sempre efficace, poiché gli scanner sono facilmente aggirabili. Un'altra opzione potrebbe essere quella di
registrarsi ad un servizio che notifichi gli sviluppatori delle vulnerabilità trovate nel codice, ma anche questa
soluzione presenta delle limitazioni, in quanto potrebbe non individuare tutte le vulnerabilità presenti nel software.
Infine, un'altra strategia possibile sarebbe quella di revisionare il codice ogni volta che si fa un update delle
dipendenze, ma questa soluzione potrebbe funzionare solo per progetti piccoli con poche dipendenze, mentre per progetti
più grandi e complessi potrebbe risultare impraticabile. Le soluzioni esistenti cercano di individuare le vulnerabilità
del software, ma non offrono una vera e propria prevenzione. La soluzione ideale sarebbe quella di prevenire le
vulnerabilità alla radice. Per arrivare alla soluzione, dobbiamo tornare un po' indietro nel tempo, in quanto è un
problema già affrontato in passato, solo con un altro tipo di granularità. \\
\\
Il problema di far coesistere due applicazioni in esecuzione senza interferenze reciproche esiste fin dai primi sistemi
operativi. La soluzione adottata è affidare al sistema operativo il compito di proteggere e controllare l'esecuzione
delle applicazioni tramite l'utilizzo dei "processi". Quando una nuova applicazione viene avviata, il sistema operativo
crea un nuovo processo con un'area di memoria dedicata, che non può accedere alle aree riservate degli altri processi.
Se il processo ha bisogno di comunicare con altri, deve prima richiedere il permesso e farlo tramite le "pipe".
\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=10cm]{./chapters/2.wasi-in-depth/images/2.process_isolation.png}
    \label{process_isolation}
    \caption{Isolamento dei processi nei sistemi operativi}
\end{figure}
Questo sistema risolve il problema della condivisione della memoria a runtime, ma non garantisce che l'applicazione, ad
esempio, non acceda al filesystem per effettuare qualche operazione non prevista.\\ 
Le VM e i container sono stati sviluppati in origine proprio per questo motivo, garantiscono che qualcosa in esecuzione
in una VM o container non possa accedere al filesystem di altri, ma non nel proprio. Con il modello "sandbox", invece,
potremmo ulteriormente isolare le applicazioni rimuovendo l'accesso alle API e alle system call del sistema prima che
l'applicazione venga eseguita. Guardando alle tre soluzioni potremmo arrivare alla conclusione che per garantire la
sicurezza e l'isolamento di ogni package sia necessario isolarlo all'interno della propria sandbox, con i giusti
permessi. Ciò però porterebbe presto ad un esaurimento delle risorse del sistema ed introdurrebbe un overhead nella
comunicazione tra i package dell'applicazione. 
\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=10cm]{./chapters/2.wasi-in-depth/images/3.package_isolation_processes.png}
    \label{process_package_in_sandbox}
    \caption{Isolamento dei package in sandbox isolate, evidente inefficienza e overhead}
\end{figure}
Come facciamo quindi a garantire l'isolamento di ogni package senza esaurire le risorse del sistema?
\subsection{La soluzione: nanoprocessi}
WebAssembly offre un'efficace forma di isolamento che previene al codice non sicuro di fare ciò che vuole, i
nanoprocessi. I nanoprocessi sono strutture simili ai processi standard di Unix ma che risultano essere più leggeri e di
dimensioni ridotte. Risiedono all'interno di un ambiente di esecuzione chiamato "sandbox", che rappresenta un processo
padre isolato dall'esterno. La memoria a cui ogni nanoprocesso ha accesso è uno slice della memoria del processo padre,
ovvero della sandbox. Per accedere ai dati di un altro modulo, un modulo deve avere l'autorizzazione esplicita per farlo
e questa autorizzazione viene passata in modo gerarchico, dall'alto verso il basso. In questo modo, la sandbox coordina
l'accesso ai dati e garantisce che ogni nanoprocesso operi in modo indipendente e sicuro, senza che vadino ad
interferire con gli altri. L'uso di nanoprocessi consente di ottimizzare le prestazioni dell'applicazione, evitando
costose chiamate di sistema e semplificando la comunicazione tra i vari moduli Wasm.
\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=10cm]{./chapters/2.wasi-in-depth/images/4.nanoprocesses.png}
    \label{nanoprocesses}
    \caption{Nanoprocessi di Wasm}
\end{figure}
Si noti che il concetto di nanoprocesso in WebAssembly è basato sui processi Unix, ma implementato attraverso un pattern
specifico di WebAssembly.\\
Tutte le caratteristiche di WebAssembly descritte finora rendono questa tecnologia una soluzione sicura per l'esecuzione
di codice al di fuori del browser. Per esempio, se del codice malevolo tentasse di accedere a un file su cui la sandbox
non ha i permessi, il modulo WebAssembly verrebbe interrotto sollevando un'eccezione e il processo finirebbe con un
errore. Inoltre, anche se la sandbox avesse i permessi per accedere a un determinato file, questi permessi potrebbero
non essere associati al modulo contenente il codice malevolo. In relazione al codice vulnerabile, sarebbe estremamente
difficile per un attaccante trovare un modulo che abbia sia l'autorizzazione a utilizzare una determinata system call
sia l'autorizzazione su un determinato file nel filesystem. \\ Si può notare come questa filosofia di WebAssembly
aderisca al principio di least authority (POLA) e al capability based model.
\subsection{Capability Based Model}
\subsection{Il problema delle socket}
\section{La gestione delle risorse}

\section{Come funzionano i runtime}
\section{Il processo di linking}
\section{Il processo di compilazione}
\section{Il processo di esecuzione}
\section{Un'analogia con la JVM}
\section{Nei container}